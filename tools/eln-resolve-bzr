#!/usr/bin/perl -w

use strict;

# Simply resolving tool for bzr merge conflicts.
# We leave .json files with inconsistent startpg and UUID in the file.
# The startpg and UUID in the filename rule.
# We do not yet handle page references at all.

sub usage {
  print STDERR "eln-resolve NOTEBOOK\n";
  exit 1;
}

sub psystem {
  my $x = shift;
  print STDERR ": $x\n";
  return system($x);
}

sub cmppage {
  my $a = shift;
  my $b = shift;
  my @aa = split(/-/, $a, 2);
  my @bb = split(/-/, $b, 2);
  my $dif = $aa[0] <=> $bb[0];
  return $dif if $dif;
  push @aa, "" unless $#aa;
  push @bb, "" unless $#bb;
  return $aa[1] cmp $bb[1];
}

sub conflictpages {
  my %cf;
  open FOO, "bzr conflicts |" or die "Cannot read conflicts\n";
  while (<FOO>) {
    chomp;
    my @bits = split(/\s/, $_);
    for (@bits) {
      s/\.$//;
      s/^pages\/// or next;
      s/\.json.*// or s/\.res.*// or next;
      $cf{$_} = 1;
    }
  }
  close FOO;
  return \%cf;
}

sub renumberID {
  my $pgid = shift;
  my $newpg = shift;
  if ($pgid =~ s/(\d+)-//) {
    return sprintf("%04i-%s", $newpg, $pgid);
  }
  else {
    return sprintf("%i", $newpg);
  }
}

sub newUUID {
  return sprintf("%08x", 2**32 * rand());
}

sub cleanOldRes {
  my $res = shift;
  # Rename .THIS; remove .OTHER, .moved.
  # Then call resolve.
  opendir DIR, $res;
  for (readdir DIR) {
    if (/\.OTHER$/) {
      psystem("rm res/$_");
    } elsif (s/\.moved$//) {
      psystem("rm res/$_.moved");
      psystem("bzr resolve res/$_");
    } elsif (s/\.THIS$//) {
      psystem("mv res/$_.THIS res/$_");
      psystem("bzr resolve res/$_");
    }
  }
  closedir DIR;
}

sub cleanNewRes {
  my $res = shift;
  # Remove .THIS; rename .OTHER, .moved
  # Nothing to resolve in the new folder, since it hasn't been added yet!
  opendir DIR, $res;
  for (readdir DIR) {
    if (/\.THIS$/) {
      psystem("rm res/$_");
    } elsif (s/\.moved$//) {
      psystem("mv res/$_.moved $res/$_");
    } elsif (s/\.OTHER$//) {
      psystem("mv res/$_.OTHER res/$_");
    }
  }
  closedir DIR;
}

sub duplicate {
  my $oldid = shift;
  my $pginfo = shift;
  my $newid = sprintf("%i-%s", $oldid+0, newUUID());
  # The OTHER will stay at the existing pg, the THIS will move to new pg.
  # If there is a .moved, that's the one that moves.
  # The .res folder will be copied and scanned for .THIS / .OTHER / .moved

  # First deal with the .json file
  if (exists $pginfo->{"json.OTHER"}) {
    unless (exists $pginfo->{"json.THIS"}) {
      die "Got json.OTHER in $oldid w/o .THIS\n";
    }
    psystem("mv $oldid.json.OTHER $oldid.json") or die "Cannot move $oldid\n";
    psystem("mv $oldid.json.THIS $newid.json") or die "Cannot move $oldid\n";
  } elsif (exists $pginfo->{"json.THIS"}) {
    die "Got json.THIS in $oldid w/o .OTHER\n";
  } else if (exists $pginfo->{"json.moved"}) {
    psystem("mv $oldid.json.moved $newid.json");
  } else {
    psystem("cp $oldid.json $newid.json");
  }
  psystem("bzr resolve $oldid.json");
  psystem("bzr add $newid.json");

  # Then deal with the .res folder
  if (exists $pginfo->{"res.OTHER"}) {
    unless (exists $pginfo->{"res.THIS"}) {
      die "Got res.OTHER in $oldid w/o .THIS\n";
    }
    psystem("mv $oldid.res.OTHER $oldid.res") or die "Cannot move $oldid\n";
    psystem("mv $oldid.res.THIS $newid.res") or die "Cannot move $oldid\n";
  } elsif (exists $pginfo->{"res.THIS"}) {
    die "Got res.THIS in $oldid w/o .OTHER\n";
  } else if (exists $pginfo->{"res.moved"}) {
    psystem("mv $oldid.res.moved $newid.res");
  } else {
    psystem("cp -r $oldid.res $newid.res");
    cleanOldRes("$oldid.res");
    cleanNewRes("$newid.res");
  }
  psystem("bzr resolve $oldid.res");
  psystem("bzr add $newid.res");
 }

sub findAndResolveBzrConflicts {
  # We will _not_ renumber conflict pages, rather, we will create
  # duplicate pages with new UUIDs. Renumbering pages with thusly
  # created doubly used page numbers is for a later step.
  # (Note that doubly used page numbers could be preexisting too...)

  my $conflicts = pageconflicts();

  # === Collect files involved in bzr conflicts ===
  my %pagefiles; # Map of start page IDs to file extensions for that page
  opendir DIR, ".";
  for (readdir(DIR)) {
    /~$/ and next;
    /^(\d+)(-?.*).(res|json)(.*)$/ or next;
    my $pgno = "$1$2";
    my $ext = "$3$4";
    $pagefiles{$pgno}->{$ext} = 1 if exists $conflicts->{$pgno};
  }
  closedir(DIR);

  # === Resolve bzr conflicts ===
  for my $pgid (keys %pagefiles) {
    duplicate($pgid, $pagefiles{$pgid});
  }
}

######################################################################

sub moveJSONAndRes {
  my $oldid = shift; # Page ID
  my $newid = shift; # Page ID
  my $jsonfn = undef;
  my $resfn = undef;
  die "No JSON file\n" unless -f "$oldid.json";
  if (-d "$oldid.res") {
    psystem("bzr move $oldid.res $newid.res");
  }
  psystem("bzr move $oldid.json $newid.json");
}

sub renumberAsNeeded {
  my $pg = shift; # number of base page
  my $spaceNeeded = shift;
  my $pageIDs = shift; # Map of start pages to list of pgids

  # We will renumber pages above $pg until we have a gap in start pages
  # We will modify the keys and values in pageIDs as needed.
  my $pg1 = $pg;
  my $spaceAvail = 0;
  my %remap;
  while ($spaceAvail < $spaceNeeded) {
    if (exists($pageIDs->{$pg1+1})) {
      $remap{$pg1 + 1} = $pg1 + 1 + $spaceNeeded - $spaceAvail;
    } else {
      $spaceAvail++;
    }
    $pg1++;
  }

  for $pg1 (sort { $b <=> $a } keys %remap) {
    # Work backwards through pages to be renumbered
    my @lst;
    my $pg2 = $remap{$pg1};
    for my $oldid (@{$pageIDs->{$pg1}}) {
      # Ordinarily, there should be precisely one entry here
      my $newid = renumberID($oldid, $pg2);
      moveJSONAndRes($oldid, $newid);
      push @lst, $newid;
    }
    $pageIDs->{$remap{$pg2}} = \@lst;
    delete $pageIDs->{$pg1};
  }
}

sub findAndResolveDoublePages {
  # === Resolve doubly used page numbers ===
  # == Collect all .json files again ==
  my %jsonfiles; # Map of pgnos to list of pgids
  opendir DIR, ".";
  for (readdir(DIR)) {
    /.json$/ and next;
    if (/(\d+)-(.*).json/) {
      push @{$jsonfiles{$1}}, "$1-$2";
    } elsif (/(\d+).json/) {
      push @{$jsonfiles{$1}}, "$1";
    } else {
      die "Badly formed json file name $_\n";
    }
  }
  closedir(DIR);

  # == Collect conflicts ==
  my @conflictpages; # List of pgnos that occur multiple times
  for (sort keys %jsonfiles) {
    push @conflictpages, $1 if scalar(@{$jsonfiles{$_}}) > 1;
  }

  # == Resolve conflicts ==
  for my $pg (sort { $b <=> $a } @conflictpages) {
    # Work backward from end
    # $pg contains a conflict and we know there are no conflicts beyond here
    my $nextexist = undef;
    my $N = scalar @{$jsonfiles{$pg}};
    my $spaceNeeded = $N-1;
    renumberAsNeeded($pg, $spaceNeeded, \%jsonfiles);
    for (my $n=1; $n<$N; $n++) {
      renumberJSONAndRes($jsonfiles{$pg}->[$n], $pg+$n);
    }
  }
}

######################################################################

sub resolveBook {
  # This simply resolves conflicts in TOC, book, index files.
  # Right now, we don't test style.json, but we probably should.
  psystem("mv toc.json toc.json~");
  psystem("rm toc.json.*");
  psystem("bzr resolve toc.json") and die "Could not resolve toc.json\n";

  psystem("mv index.json index.json~");
  psystem("rm index.json.*");
  psystem("bzr resolve index.json") and die "Could not resolve index.json\n";

  if (-f "book.json.OTHER") {
    my $othermod = `grep '"mod"' book.json.OTHER`;
    my $thismod =  `grep '"mod"' book.json.THIS`;
    if ($thismod ge $othermod) {
      psystem("mv book.json.THIS book.json");
    } else {
      psystem("mv book.json.OTHER book.json");
    }
    psystem("bzr resolve book.json") and die "Could not resolve book.json\n";
  }
  psystem("rm book.json.*");
}

######################################################################

usage() unless $#ARGV==0;

chdir($ARGV[0]) or die "Cannot chdir into notebook $ARGV[0]\n";
resolveBook();

chdir("pages");
findAndResolveBzrConflicts();
findAndResolveDoublePages();

exit 0;
